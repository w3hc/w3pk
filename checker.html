<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>w3pk SDK Tester</title>
    <style>
      body {
        font-family: system-ui, -apple-system, sans-serif;
        max-width: 1200px;
        margin: 20px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #333;
        margin-bottom: 10px;
      }
      .subtitle {
        color: #666;
        margin-bottom: 30px;
      }
      .button-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 10px;
        margin-bottom: 20px;
      }
      button {
        padding: 12px 20px;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #007bff;
        color: white;
        transition: background 0.2s;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .result {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 4px;
        border-left: 4px solid #007bff;
      }
      .error {
        border-left-color: #dc3545;
        background: #f8d7da;
      }
      .success {
        border-left-color: #28a745;
        background: #d4edda;
      }
      .empty {
        border-left-color: #6c757d;
      }
      pre {
        background: #272822;
        color: #f8f8f2;
        padding: 15px;
        border-radius: 4px;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 400px;
        overflow-y: auto;
      }
      .section {
        margin-bottom: 30px;
      }
      .section h2 {
        color: #333;
        margin-bottom: 15px;
        font-size: 18px;
      }
      .info {
        background: #e7f3ff;
        border-left: 4px solid #2196f3;
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 4px;
      }
      .key {
        font-weight: bold;
        color: #007bff;
        margin-top: 15px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>w3pk SDK Tester</h1>
      <p class="subtitle">Browser-based testing for Web3 Passkey SDK</p>

      <div class="info">
        <strong>Note:</strong> This page uses the local build of w3pk. Open the browser console to see detailed logs.
        <br><strong>Requirements:</strong> Run <code>npm run html</code> to build and serve.
      </div>

      <div class="section">
        <h2>Authentication</h2>
        <div class="button-grid">
          <button onclick="testRegister()">Register New User</button>
          <button onclick="testLogin()">Login</button>
          <button onclick="testLogout()">Logout</button>
          <button onclick="checkAuth()">Check Auth Status</button>
        </div>
      </div>

      <div class="section">
        <h2>Wallet Operations</h2>
        <div class="button-grid">
          <button onclick="testDeriveWallet()">Derive Wallet (index 0)</button>
          <button onclick="testDeriveMultiple()">Derive Multiple Wallets</button>
          <button onclick="testExportMnemonic()">Export Mnemonic</button>
          <button onclick="testSignMessage()">Sign Message</button>
        </div>
      </div>

      <div class="section">
        <h2>Session Management</h2>
        <div class="button-grid">
          <button onclick="checkSession()">Check Session Status</button>
          <button onclick="extendSession()">Extend Session</button>
          <button onclick="clearSession()">Clear Session</button>
          <button onclick="testForceAuth()">Test Force Auth</button>
        </div>
      </div>

      <div class="section">
        <h2>RPC & Network</h2>
        <div class="button-grid">
          <button onclick="testGetEndpoints()">Get Ethereum RPCs</button>
          <button onclick="testEIP7702()">Check EIP-7702 Support</button>
        </div>
      </div>

      <div class="section">
        <h2>ERC-5564 Stealth Addresses</h2>
        <div class="button-grid">
          <button onclick="testGetStealthMetaAddress()">Get Stealth Meta-Address</button>
          <button onclick="testGenerateStealthAddress()">Generate Stealth Address</button>
          <button onclick="testParseAnnouncement()">Parse Announcement</button>
          <button onclick="testScanAnnouncements()">Scan Announcements</button>
          <button onclick="testGetStealthKeys()">Get Stealth Keys</button>
        </div>
      </div>

      <div class="section">
        <h2>ZK Primitives - Proof Generation</h2>
        <div class="button-grid">
          <button onclick="testProveMembership()">Prove Membership</button>
          <button onclick="testProveThreshold()">Prove Threshold</button>
          <button onclick="testProveRange()">Prove Range</button>
          <button onclick="testProveOwnership()">Prove Ownership</button>
          <button onclick="testProveNFTOwnership()">Prove NFT Ownership</button>
        </div>
      </div>

      <div class="section">
        <h2>ZK Primitives - Verification</h2>
        <div class="button-grid">
          <button onclick="testVerifyProof()">Verify Proof</button>
          <button onclick="testCreateCommitment()">Create Commitment</button>
          <button onclick="testComputeMerkleRoot()">Compute Merkle Root</button>
        </div>
      </div>

      <div class="section">
        <h2>Backup & Recovery</h2>
        <div class="button-grid">
          <button onclick="testGetBackupStatus()">Get Backup Status</button>
          <button onclick="testCreateZipBackup()">Create ZIP Backup</button>
          <button onclick="testCreateQRBackup()">Create QR Backup</button>
          <button onclick="testRestoreFromBackup()">Restore from Backup</button>
          <button onclick="testRestoreFromQR()">Restore from QR</button>
          <button onclick="testDetectSyncCapabilities()">Detect Sync Capabilities</button>
        </div>
      </div>

      <div class="section">
        <h2>Social Recovery</h2>
        <div class="button-grid">
          <button onclick="testSetupSocialRecovery()">Setup Social Recovery (3-of-5)</button>
          <button onclick="testGenerateGuardianInvite()">Generate Guardian Invite</button>
          <button onclick="testGetSocialRecoveryConfig()">View Social Recovery Config</button>
        </div>
      </div>

      <div class="section">
        <h2>Education & Testing</h2>
        <div class="button-grid">
          <button onclick="testRunRecoveryTest()">Run Recovery Test</button>
          <button onclick="testSimulateLostDevice()">Simulate: Lost Device</button>
          <button onclick="testSimulateLostPhrase()">Simulate: Lost Phrase</button>
          <button onclick="testGetEducation()">Get Education (Passkeys)</button>
        </div>
      </div>

      <div class="section">
        <h2>Storage - LocalStorage</h2>
        <div class="button-grid">
          <button onclick="checkStorage()">View LocalStorage</button>
          <button onclick="clearStorage()">Clear LocalStorage</button>
        </div>
      </div>

      <div class="section">
        <h2>Storage - IndexedDB</h2>
        <div class="button-grid">
          <button onclick="checkIndexedDB()">View IndexedDB Data</button>
          <button onclick="checkIndexedDBSize()">Get Storage Size</button>
          <button onclick="exportIndexedDB()">Export IndexedDB</button>
          <button onclick="clearIndexedDB()">Clear IndexedDB</button>
          <button onclick="checkAllStorage()">View All Storage</button>
        </div>
      </div>

      <div id="results"></div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "@simplewebauthn/browser": "https://esm.sh/@simplewebauthn/browser@13.2.2",
          "ethers": "https://esm.sh/ethers@6.13.0"
        }
      }
    </script>
    <script type="module">
      // Import from local build
      import { createWeb3Passkey } from './dist/index.mjs';

      // Make it globally available for onclick handlers
      // Enable stealth addresses and ZK primitives
      window.w3pk = createWeb3Passkey({
        sessionDuration: 1,
        stealthAddresses: {},
        zkProofs: {}
      });

      // Helper functions
      window.showResult = function(message, data, type = 'result') {
        const resultsDiv = document.getElementById('results');
        const div = document.createElement('div');
        div.className = `result ${type}`;

        let html = `<strong>${message}</strong>`;
        if (data) {
          html += '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }
        div.innerHTML = html;

        resultsDiv.insertBefore(div, resultsDiv.firstChild);
      };

      window.handleError = function(error) {
        console.error(error);
        window.showResult('Error: ' + error.message, null, 'error');
      };

      // Test functions
      window.testRegister = async function() {
        try {
          const username = 'user_' + Date.now();
          const result = await window.w3pk.register({ username });
          console.log('Registration result:', result);
          window.showResult(`User registered: ${result.username}`, {
            username: result.username,
            address: result.address,
            isAuthenticated: window.w3pk.isAuthenticated,
            user: window.w3pk.user
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testLogin = async function() {
        try {
          const user = await window.w3pk.login();
          console.log('Login result:', user);
          window.showResult('Login successful', user, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testLogout = async function() {
        try {
          await window.w3pk.logout();
          console.log('Logged out');
          window.showResult('Logout successful', { isAuthenticated: window.w3pk.isAuthenticated }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.checkAuth = function() {
        const data = {
          isAuthenticated: window.w3pk.isAuthenticated,
          user: window.w3pk.user
        };
        console.log('Auth status:', data);
        window.showResult('Authentication Status', data);
      };

      window.testDeriveWallet = async function() {
        try {
          const wallet = await window.w3pk.deriveWallet(0);
          console.log('Derived wallet:', wallet);
          window.showResult('Wallet Derived (index 0)', wallet, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testDeriveMultiple = async function() {
        try {
          const wallets = await Promise.all([
            window.w3pk.deriveWallet(0),
            window.w3pk.deriveWallet(1),
            window.w3pk.deriveWallet(2)
          ]);
          console.log('Multiple wallets:', wallets);
          window.showResult('Multiple Wallets Derived', wallets, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testExportMnemonic = async function() {
        try {
          const mnemonic = await window.w3pk.exportMnemonic();
          console.log('Mnemonic:', mnemonic);
          window.showResult('Mnemonic Exported', { mnemonic }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testSignMessage = async function() {
        try {
          const message = 'Hello Web3! Timestamp: ' + Date.now();
          const signature = await window.w3pk.signMessage(message);
          console.log('Signature:', signature);
          window.showResult('Message Signed', { message, signature }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.checkSession = function() {
        const data = {
          hasActiveSession: window.w3pk.hasActiveSession(),
          remainingTimeSeconds: window.w3pk.getSessionRemainingTime()
        };
        console.log('Session status:', data);
        window.showResult('Session Status', data);
      };

      window.extendSession = function() {
        try {
          window.w3pk.extendSession();
          const data = {
            hasActiveSession: window.w3pk.hasActiveSession(),
            remainingTimeSeconds: window.w3pk.getSessionRemainingTime()
          };
          console.log('Session extended:', data);
          window.showResult('Session Extended', data, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.clearSession = function() {
        window.w3pk.clearSession();
        const data = {
          hasActiveSession: window.w3pk.hasActiveSession()
        };
        console.log('Session cleared:', data);
        window.showResult('Session Cleared', data, 'success');
      };

      window.testForceAuth = async function() {
        try {
          const signature = await window.w3pk.signMessage('Force auth test', { requireAuth: true });
          console.log('Forced auth signature:', signature);
          window.showResult('Forced Authentication Successful', { signature }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGetEndpoints = async function() {
        try {
          const endpoints = await window.w3pk.getEndpoints(1); // Ethereum
          console.log('Ethereum endpoints:', endpoints);
          window.showResult('Ethereum RPC Endpoints', { count: endpoints.length, endpoints: endpoints.slice(0, 5) }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testEIP7702 = async function() {
        try {
          window.showResult('Checking EIP-7702 support...', null);
          const supported = await window.w3pk.supportsEIP7702(1);
          console.log('EIP-7702 support:', supported);
          window.showResult('EIP-7702 Support Check', { chainId: 1, supported }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.checkStorage = function() {
        const allData = {};
        let foundCount = localStorage.length;

        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key) {
            const value = localStorage.getItem(key);
            try {
              allData[key] = JSON.parse(value);
            } catch {
              allData[key] = value;
            }
          }
        }

        if (foundCount === 0) {
          window.showResult('No data found in local storage.', null, 'empty');
        } else {
          let html = `<div class="result"><strong>Found ${foundCount} item(s) in local storage:</strong>`;

          for (const [key, value] of Object.entries(allData)) {
            html += `<div class="key">${key}:</div>`;
            html += "<pre>" + JSON.stringify(value, null, 2) + "</pre>";
          }

          html += '</div>';
          document.getElementById('results').insertAdjacentHTML('afterbegin', html);
        }

        console.log('LocalStorage:', allData);
      };

      window.clearStorage = function() {
        if (confirm('This will clear ALL localStorage data. Are you sure?')) {
          localStorage.clear();
          console.log('Storage cleared');
          window.showResult('All Storage Cleared', null, 'success');
        }
      };

      // Backup & Recovery Functions
      window.testGetBackupStatus = async function() {
        try {
          const status = await window.w3pk.getBackupStatus();
          console.log('Backup status:', status);
          window.showResult('Backup Status', {
            securityScore: status.securityScore.total + '/100',
            level: status.securityScore.level,
            passkeySync: status.passkeySync.enabled,
            platform: status.passkeySync.platform,
            encryptedBackups: status.recoveryPhrase.encryptedBackups.length,
            socialRecovery: status.socialRecovery?.enabled || false
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testCreateZipBackup = async function() {
        try {
          const password = prompt('Enter a strong password for the backup:', 'TestPassword123!');
          if (!password) return;

          const blob = await window.w3pk.createZipBackup(password, {
            includeInstructions: true,
            deviceBinding: false
          });

          // Create download link
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `wallet-backup-${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);

          console.log('ZIP backup created');
          window.showResult('ZIP Backup Created', {
            size: `${(blob.size / 1024).toFixed(2)} KB`,
            password: password,
            note: 'File downloaded automatically'
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testCreateQRBackup = async function() {
        try {
          const password = prompt('Enter password for QR backup (or leave empty for unencrypted):', '');

          const result = await window.w3pk.createQRBackup(password || undefined, {
            errorCorrection: 'H'
          });

          console.log('QR backup created');

          // Display QR code in results
          const img = new Image();
          img.src = result.qrCodeDataURL;
          img.style.maxWidth = '400px';
          img.style.border = '2px solid #007bff';
          img.style.borderRadius = '8px';
          img.style.marginTop = '10px';

          const div = document.createElement('div');
          div.className = 'result success';
          div.innerHTML = `
            <strong>QR Code Backup Created</strong>
            <p>Encrypted: ${password ? 'Yes' : 'No'}</p>
            <p>Error Correction: High (30% damage tolerance)</p>
            <div>${img.outerHTML}</div>
            <details style="margin-top: 10px;">
              <summary>View Instructions</summary>
              <pre>${result.instructions}</pre>
            </details>
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testDetectSyncCapabilities = async function() {
        try {
          const capabilities = await window.w3pk.detectSyncCapabilities();
          console.log('Sync capabilities:', capabilities);

          const syncStatus = await window.w3pk.getSyncStatus();
          console.log('Sync status:', syncStatus);

          window.showResult('Sync Capabilities Detected', {
            platform: capabilities.platform,
            passkeysSync: capabilities.passkeysSync,
            estimatedDevices: capabilities.estimatedDevices,
            syncEnabled: capabilities.syncEnabled,
            devices: syncStatus.devices
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      // Social Recovery Functions
      window.testSetupSocialRecovery = async function() {
        try {
          const guardians = [
            { name: 'Alice', email: 'alice@example.com' },
            { name: 'Bob', email: 'bob@example.com' },
            { name: 'Charlie', email: 'charlie@example.com' },
            { name: 'Diana', email: 'diana@example.com' },
            { name: 'Eve', email: 'eve@example.com' }
          ];

          window.showResult('Setting up social recovery (this will require authentication)...', null);

          const result = await window.w3pk.setupSocialRecovery(guardians, 3);
          console.log('Social recovery setup:', result);

          window.showResult('Social Recovery Setup Complete', {
            totalGuardians: result.length,
            threshold: 3,
            guardians: result.map(g => ({
              id: g.id,
              name: g.name,
              status: g.status
            }))
          }, 'success');

          // Store first guardian ID for testing
          if (result.length > 0) {
            window.testGuardianId = result[0].id;
          }
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGenerateGuardianInvite = async function() {
        try {
          if (!window.testGuardianId) {
            window.showResult('Please set up social recovery first', null, 'error');
            return;
          }

          const invite = await window.w3pk.generateGuardianInvite(window.testGuardianId);
          console.log('Guardian invite:', invite);

          // Display QR code and explainer
          const img = new Image();
          img.src = invite.qrCode;
          img.style.maxWidth = '300px';
          img.style.border = '2px solid #28a745';
          img.style.borderRadius = '8px';

          const div = document.createElement('div');
          div.className = 'result success';
          div.innerHTML = `
            <strong>Guardian Invitation Generated</strong>
            <p>Guardian ID: ${invite.guardianId}</p>
            <div>${img.outerHTML}</div>
            <details style="margin-top: 10px;">
              <summary>View Guardian Instructions</summary>
              <pre>${invite.explainer}</pre>
            </details>
            <details style="margin-top: 10px;">
              <summary>View Share Code (JSON)</summary>
              <pre>${invite.shareCode}</pre>
            </details>
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGetSocialRecoveryConfig = async function() {
        try {
          // Import SocialRecoveryManager
          const { SocialRecoveryManager } = await import('./dist/index.mjs');
          const socialRecovery = new SocialRecoveryManager();

          const config = socialRecovery.getSocialRecoveryConfig();

          if (!config) {
            window.showResult('Social recovery not configured yet', null, 'empty');
            return;
          }

          console.log('Social recovery config:', config);
          window.showResult('Social Recovery Configuration', {
            threshold: config.threshold,
            totalGuardians: config.totalGuardians,
            ethereumAddress: config.ethereumAddress,
            createdAt: new Date(config.createdAt).toISOString(),
            guardians: config.guardians.map(g => ({
              name: g.name,
              email: g.email,
              status: g.status,
              addedAt: new Date(g.addedAt).toISOString()
            }))
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      // Education & Testing Functions
      window.testRunRecoveryTest = async function() {
        try {
          window.showResult('Running recovery test...', null);

          const result = await window.w3pk.runRecoveryTest();
          console.log('Recovery test:', result);

          let scenariosHtml = '<div style="margin-top: 10px;"><strong>Scenarios:</strong></div>';
          result.scenarios.forEach(scenario => {
            const icon = scenario.success ? '✅' : '❌';
            scenariosHtml += `<div style="margin: 5px 0;">${icon} ${scenario.scenario.description}</div>`;
          });

          const div = document.createElement('div');
          div.className = 'result ' + (result.overallScore >= 75 ? 'success' : 'error');
          div.innerHTML = `
            <strong>Recovery Test Complete</strong>
            <p>Overall Score: ${result.overallScore}/100</p>
            ${scenariosHtml}
            <pre style="margin-top: 10px;">${result.feedback}</pre>
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testSimulateLostDevice = async function() {
        try {
          const result = await window.w3pk.simulateRecoveryScenario({
            type: 'lost-device',
            description: 'Your phone fell in the ocean'
          });
          console.log('Lost device simulation:', result);

          let methodsHtml = '<div style="margin-top: 10px;"><strong>Available Methods:</strong></div>';
          result.availableMethods.forEach((method, index) => {
            methodsHtml += `<div style="margin: 5px 0;">${index + 1}. ${method.method} (~${method.time})</div>`;
          });

          const div = document.createElement('div');
          div.className = 'result ' + (result.success ? 'success' : 'error');
          div.innerHTML = `
            <strong>Scenario: Lost Device</strong>
            <p>Can Recover: ${result.success ? 'Yes ✅' : 'No ❌'}</p>
            <p>Fastest Recovery: ${result.timeEstimate}</p>
            ${methodsHtml}
            <pre style="margin-top: 10px;">${result.educationalNote}</pre>
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testSimulateLostPhrase = async function() {
        try {
          const result = await window.w3pk.simulateRecoveryScenario({
            type: 'lost-phrase',
            description: 'Your paper backup burned in a fire'
          });
          console.log('Lost phrase simulation:', result);

          let methodsHtml = '<div style="margin-top: 10px;"><strong>Available Methods:</strong></div>';
          result.availableMethods.forEach((method, index) => {
            methodsHtml += `<div style="margin: 5px 0;">${index + 1}. ${method.method} (~${method.time})</div>`;
          });

          const div = document.createElement('div');
          div.className = 'result ' + (result.success ? 'success' : 'error');
          div.innerHTML = `
            <strong>Scenario: Lost Recovery Phrase</strong>
            <p>Can Recover: ${result.success ? 'Yes ✅' : 'No ❌'}</p>
            <p>Fastest Recovery: ${result.timeEstimate}</p>
            ${methodsHtml}
            <pre style="margin-top: 10px;">${result.educationalNote}</pre>
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGetEducation = async function() {
        try {
          const content = await window.w3pk.getEducation('whatIsPasskey');
          console.log('Educational content:', content);

          const div = document.createElement('div');
          div.className = 'result';
          div.innerHTML = `
            <strong>${content.title}</strong>
            <pre>${content.content}</pre>
            ${content.visual ? `<pre>${content.visual}</pre>` : ''}
          `;
          document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild);
        } catch (error) {
          window.handleError(error);
        }
      };

      // ERC-5564 Stealth Address Functions
      window.testGetStealthMetaAddress = async function() {
        try {
          if (!window.w3pk.stealth) {
            window.showResult('Stealth addresses not enabled. Reinitialize SDK with stealthAddresses config.', null, 'error');
            return;
          }
          const metaAddress = await window.w3pk.stealth.getStealthMetaAddress();
          console.log('Stealth meta-address:', metaAddress);
          window.showResult('Stealth Meta-Address', { metaAddress }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGenerateStealthAddress = async function() {
        try {
          if (!window.w3pk.stealth) {
            window.showResult('Stealth addresses not enabled', null, 'error');
            return;
          }
          const announcement = await window.w3pk.stealth.generateStealthAddress();
          console.log('Generated stealth address:', announcement);
          window.showResult('Stealth Address Generated', announcement, 'success');

          // Store for testing parseAnnouncement
          window.testAnnouncement = announcement;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testParseAnnouncement = async function() {
        try {
          if (!window.w3pk.stealth) {
            window.showResult('Stealth addresses not enabled', null, 'error');
            return;
          }
          if (!window.testAnnouncement) {
            window.showResult('Please generate a stealth address first', null, 'error');
            return;
          }

          const result = await window.w3pk.stealth.parseAnnouncement({
            stealthAddress: window.testAnnouncement.stealthAddress,
            ephemeralPublicKey: window.testAnnouncement.ephemeralPublicKey,
            viewTag: window.testAnnouncement.viewTag
          });

          console.log('Parse announcement result:', result);
          window.showResult('Announcement Parsed', {
            isForUser: result.isForUser,
            stealthAddress: result.stealthAddress,
            hasPrivateKey: !!result.stealthPrivateKey
          }, result.isForUser ? 'success' : 'result');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testScanAnnouncements = async function() {
        try {
          if (!window.w3pk.stealth) {
            window.showResult('Stealth addresses not enabled', null, 'error');
            return;
          }

          // Generate a few test announcements first
          const announcements = [];
          for (let i = 0; i < 3; i++) {
            const ann = await window.w3pk.stealth.generateStealthAddress();
            announcements.push({
              stealthAddress: ann.stealthAddress,
              ephemeralPublicKey: ann.ephemeralPublicKey,
              viewTag: ann.viewTag
            });
          }

          window.showResult('Scanning announcements...', null);
          const results = await window.w3pk.stealth.scanAnnouncements(announcements);
          console.log('Scan results:', results);

          window.showResult('Announcements Scanned', {
            total: announcements.length,
            found: results.length,
            addresses: results.map(r => r.stealthAddress)
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testGetStealthKeys = async function() {
        try {
          if (!window.w3pk.stealth) {
            window.showResult('Stealth addresses not enabled', null, 'error');
            return;
          }
          const keys = await window.w3pk.stealth.getKeys();
          console.log('Stealth keys obtained');
          window.showResult('Stealth Keys Retrieved', {
            hasViewingKey: !!keys.viewingPrivateKey,
            hasSpendingKey: !!keys.spendingPrivateKey,
            note: 'Private keys hidden for security'
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      // ZK Proof Functions
      window.testProveMembership = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled. Reinitialize SDK with zkProofs config.', null, 'error');
            return;
          }

          window.showResult('Generating membership proof...', null);

          // Create a set and prove membership
          const members = ['0x123', '0x456', '0x789', '0xabc', '0xdef'];
          const secret = '0x456'; // We're proving we're in the set without revealing which one

          const proof = await window.w3pk.zk.proveMembership(members, secret);
          console.log('Membership proof:', proof);

          window.showResult('Membership Proof Generated', {
            proofType: proof.type,
            merkleRoot: proof.publicSignals.root,
            hasProof: !!proof.proof,
            note: 'Proves membership without revealing identity'
          }, 'success');

          window.testMembershipProof = proof;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testProveThreshold = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          window.showResult('Generating threshold proof...', null);

          // Prove balance exceeds 1000 without revealing exact amount
          const value = 5000;
          const threshold = 1000;

          const proof = await window.w3pk.zk.proveThreshold(value, threshold);
          console.log('Threshold proof:', proof);

          window.showResult('Threshold Proof Generated', {
            proofType: proof.type,
            threshold: proof.publicSignals.threshold,
            note: 'Proves value > threshold without revealing exact value'
          }, 'success');

          window.testThresholdProof = proof;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testProveRange = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          window.showResult('Generating range proof...', null);

          // Prove age is between 18 and 100 without revealing exact age
          const value = 25;
          const min = 18;
          const max = 100;

          const proof = await window.w3pk.zk.proveRange(value, min, max);
          console.log('Range proof:', proof);

          window.showResult('Range Proof Generated', {
            proofType: proof.type,
            range: `${proof.publicSignals.min} - ${proof.publicSignals.max}`,
            note: 'Proves value in range without revealing exact value'
          }, 'success');

          window.testRangeProof = proof;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testProveOwnership = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          window.showResult('Generating ownership proof...', null);

          // Get current wallet address
          const wallet = await window.w3pk.deriveWallet(0);

          const proof = await window.w3pk.zk.proveOwnership(wallet.address);
          console.log('Ownership proof:', proof);

          window.showResult('Ownership Proof Generated', {
            proofType: proof.type,
            address: proof.publicSignals.address,
            note: 'Proves you control address without revealing private key'
          }, 'success');

          window.testOwnershipProof = proof;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testProveNFTOwnership = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          window.showResult('Generating NFT ownership proof...', null);

          // Example: Prove ownership of an NFT without revealing which one
          const contractAddress = '0x1234567890123456789012345678901234567890';
          const tokenIds = [1, 5, 10, 15, 20];
          const ownedTokenId = 10;

          const proof = await window.w3pk.zk.proveNFTOwnership(
            contractAddress,
            tokenIds,
            ownedTokenId
          );
          console.log('NFT ownership proof:', proof);

          window.showResult('NFT Ownership Proof Generated', {
            proofType: proof.type,
            contractAddress: proof.publicSignals.contractAddress,
            note: 'Proves NFT ownership without revealing token ID'
          }, 'success');

          window.testNFTProof = proof;
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testVerifyProof = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          // Try to verify a previously generated proof
          let proofToVerify = window.testMembershipProof || window.testThresholdProof || window.testRangeProof;

          if (!proofToVerify) {
            window.showResult('Please generate a proof first (membership, threshold, or range)', null, 'error');
            return;
          }

          window.showResult('Verifying proof...', null);

          const isValid = await window.w3pk.zk.verify(proofToVerify);
          console.log('Proof verification result:', isValid);

          window.showResult('Proof Verification Result', {
            proofType: proofToVerify.type,
            isValid: isValid,
            status: isValid ? '✅ Valid' : '❌ Invalid'
          }, isValid ? 'success' : 'error');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testCreateCommitment = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          const value = 12345;
          const salt = Date.now().toString();

          const commitment = await window.w3pk.zk.createCommitment(value, salt);
          console.log('Commitment created:', commitment);

          window.showResult('Pedersen Commitment Created', {
            commitment: commitment,
            originalValue: value,
            salt: salt,
            note: 'Commitment hides the value until revealed'
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testComputeMerkleRoot = async function() {
        try {
          if (!window.w3pk.zk) {
            window.showResult('ZK proofs not enabled', null, 'error');
            return;
          }

          const leaves = ['0xaaa', '0xbbb', '0xccc', '0xddd', '0xeee'];

          const root = await window.w3pk.zk.computeMerkleRoot(leaves);
          console.log('Merkle root:', root);

          window.showResult('Merkle Root Computed', {
            root: root,
            leafCount: leaves.length,
            leaves: leaves,
            note: 'Used for membership proofs'
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      // Wallet Restore Functions
      window.testRestoreFromBackup = async function() {
        try {
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.json';

          fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const password = prompt('Enter backup password:', '');
            if (!password) return;

            const text = await file.text();
            const encryptedData = JSON.parse(text);

            window.showResult('Restoring from backup...', null);

            await window.w3pk.restoreFromBackup(encryptedData, password);
            console.log('Restored from backup');

            window.showResult('Wallet Restored from Backup', {
              address: window.w3pk.user?.address,
              username: window.w3pk.user?.username
            }, 'success');
          };

          fileInput.click();
        } catch (error) {
          window.handleError(error);
        }
      };

      window.testRestoreFromQR = async function() {
        try {
          const qrData = prompt('Enter QR code data (or use test data):', 'test-qr-data');
          if (!qrData) return;

          const password = prompt('Enter QR password (leave empty if unencrypted):', '');

          window.showResult('Restoring from QR...', null);

          await window.w3pk.restoreFromQR(qrData, password || undefined);
          console.log('Restored from QR');

          window.showResult('Wallet Restored from QR', {
            address: window.w3pk.user?.address,
            username: window.w3pk.user?.username
          }, 'success');
        } catch (error) {
          window.handleError(error);
        }
      };

      // IndexedDB Functions
      window.checkIndexedDB = async function() {
        try {
          const DB_NAME = 'Web3PasskeyWallet';
          const STORE_NAME = 'wallets';

          const request = indexedDB.open(DB_NAME);

          request.onsuccess = function() {
            const db = request.result;

            if (!db.objectStoreNames.contains(STORE_NAME)) {
              window.showResult('IndexedDB exists but no wallet store found', null, 'empty');
              db.close();
              return;
            }

            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const getAllRequest = store.getAll();

            getAllRequest.onsuccess = function() {
              const data = getAllRequest.result;

              if (data.length === 0) {
                window.showResult('IndexedDB is empty', { database: DB_NAME, store: STORE_NAME }, 'empty');
              } else {
                // Mask sensitive data for display
                const maskedData = data.map(item => ({
                  ethereumAddress: item.ethereumAddress,
                  credentialId: item.credentialId ? `${item.credentialId.substring(0, 20)}...` : 'N/A',
                  encryptedMnemonic: item.encryptedMnemonic ? `[${item.encryptedMnemonic.length} bytes]` : 'N/A',
                  iv: item.iv ? `${item.iv.substring(0, 20)}...` : 'N/A',
                  timestamp: item.timestamp ? new Date(item.timestamp).toISOString() : 'N/A'
                }));

                window.showResult('IndexedDB Data', {
                  database: DB_NAME,
                  store: STORE_NAME,
                  count: data.length,
                  wallets: maskedData
                }, 'success');
              }

              db.close();
            };

            getAllRequest.onerror = function() {
              window.showResult('Error reading IndexedDB', { error: getAllRequest.error }, 'error');
              db.close();
            };
          };

          request.onerror = function() {
            window.showResult('Error opening IndexedDB', { error: request.error }, 'error');
          };
        } catch (error) {
          window.handleError(error);
        }
      };

      window.checkIndexedDBSize = async function() {
        try {
          if ('storage' in navigator && 'estimate' in navigator.storage) {
            const estimate = await navigator.storage.estimate();
            const usageInMB = (estimate.usage / (1024 * 1024)).toFixed(2);
            const quotaInMB = (estimate.quota / (1024 * 1024)).toFixed(2);
            const percentUsed = ((estimate.usage / estimate.quota) * 100).toFixed(2);

            window.showResult('Storage Quota Information', {
              usage: `${usageInMB} MB`,
              quota: `${quotaInMB} MB`,
              percentUsed: `${percentUsed}%`,
              available: `${(quotaInMB - usageInMB).toFixed(2)} MB`,
              note: 'Includes IndexedDB, LocalStorage, Cache API, etc.'
            }, 'success');
          } else {
            window.showResult('Storage API not supported in this browser', null, 'error');
          }
        } catch (error) {
          window.handleError(error);
        }
      };

      window.exportIndexedDB = async function() {
        try {
          const DB_NAME = 'Web3PasskeyWallet';
          const STORE_NAME = 'wallets';

          const request = indexedDB.open(DB_NAME);

          request.onsuccess = function() {
            const db = request.result;

            if (!db.objectStoreNames.contains(STORE_NAME)) {
              window.showResult('No wallet store found', null, 'error');
              db.close();
              return;
            }

            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const getAllRequest = store.getAll();

            getAllRequest.onsuccess = function() {
              const data = getAllRequest.result;

              if (data.length === 0) {
                window.showResult('No data to export', null, 'empty');
                db.close();
                return;
              }

              // Create JSON export
              const exportData = {
                exportDate: new Date().toISOString(),
                database: DB_NAME,
                store: STORE_NAME,
                count: data.length,
                data: data
              };

              const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `w3pk-indexeddb-export-${Date.now()}.json`;
              a.click();
              URL.revokeObjectURL(url);

              window.showResult('IndexedDB Exported', {
                count: data.length,
                size: `${(blob.size / 1024).toFixed(2)} KB`,
                note: 'File downloaded successfully'
              }, 'success');

              db.close();
            };

            getAllRequest.onerror = function() {
              window.showResult('Error exporting IndexedDB', { error: getAllRequest.error }, 'error');
              db.close();
            };
          };

          request.onerror = function() {
            window.showResult('Error opening IndexedDB', { error: request.error }, 'error');
          };
        } catch (error) {
          window.handleError(error);
        }
      };

      window.clearIndexedDB = async function() {
        try {
          if (!confirm('This will delete ALL wallet data from IndexedDB. Are you sure?')) {
            return;
          }

          const DB_NAME = 'Web3PasskeyWallet';

          // Delete the entire database
          const deleteRequest = indexedDB.deleteDatabase(DB_NAME);

          deleteRequest.onsuccess = function() {
            console.log('IndexedDB cleared successfully');
            window.showResult('IndexedDB Cleared', {
              database: DB_NAME,
              note: 'All wallet data has been deleted'
            }, 'success');
          };

          deleteRequest.onerror = function() {
            window.showResult('Error clearing IndexedDB', { error: deleteRequest.error }, 'error');
          };

          deleteRequest.onblocked = function() {
            window.showResult('IndexedDB deletion blocked', {
              note: 'Close all tabs using this database and try again'
            }, 'error');
          };
        } catch (error) {
          window.handleError(error);
        }
      };

      window.checkAllStorage = async function() {
        try {
          // Get localStorage
          const localStorageData = {};
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key) {
              try {
                localStorageData[key] = JSON.parse(localStorage.getItem(key));
              } catch {
                localStorageData[key] = localStorage.getItem(key);
              }
            }
          }

          // Get IndexedDB
          const DB_NAME = 'Web3PasskeyWallet';
          const STORE_NAME = 'wallets';

          const request = indexedDB.open(DB_NAME);

          request.onsuccess = function() {
            const db = request.result;
            let indexedDBData = [];

            if (db.objectStoreNames.contains(STORE_NAME)) {
              const transaction = db.transaction([STORE_NAME], 'readonly');
              const store = transaction.objectStore(STORE_NAME);
              const getAllRequest = store.getAll();

              getAllRequest.onsuccess = function() {
                indexedDBData = getAllRequest.result.map(item => ({
                  ethereumAddress: item.ethereumAddress,
                  credentialId: item.credentialId ? `${item.credentialId.substring(0, 20)}...` : 'N/A',
                  hasEncryptedData: !!item.encryptedMnemonic,
                  timestamp: item.timestamp ? new Date(item.timestamp).toISOString() : 'N/A'
                }));

                // Get storage estimate
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                  navigator.storage.estimate().then(estimate => {
                    const summary = {
                      localStorage: {
                        count: localStorage.length,
                        keys: Object.keys(localStorageData),
                        data: localStorageData
                      },
                      indexedDB: {
                        database: DB_NAME,
                        count: indexedDBData.length,
                        wallets: indexedDBData
                      },
                      storageQuota: {
                        usage: `${(estimate.usage / (1024 * 1024)).toFixed(2)} MB`,
                        quota: `${(estimate.quota / (1024 * 1024)).toFixed(2)} MB`,
                        percentUsed: `${((estimate.usage / estimate.quota) * 100).toFixed(2)}%`
                      }
                    };

                    window.showResult('Complete Storage Overview', summary, 'success');
                    db.close();
                  });
                } else {
                  const summary = {
                    localStorage: {
                      count: localStorage.length,
                      keys: Object.keys(localStorageData),
                      data: localStorageData
                    },
                    indexedDB: {
                      database: DB_NAME,
                      count: indexedDBData.length,
                      wallets: indexedDBData
                    }
                  };

                  window.showResult('Complete Storage Overview', summary, 'success');
                  db.close();
                }
              };

              getAllRequest.onerror = function() {
                window.showResult('Error reading IndexedDB', { error: getAllRequest.error }, 'error');
                db.close();
              };
            } else {
              window.showResult('Complete Storage Overview', {
                localStorage: {
                  count: localStorage.length,
                  keys: Object.keys(localStorageData),
                  data: localStorageData
                },
                indexedDB: {
                  note: 'No wallet store found'
                }
              }, 'success');
              db.close();
            }
          };

          request.onerror = function() {
            window.showResult('Error opening IndexedDB', { error: request.error }, 'error');
          };
        } catch (error) {
          window.handleError(error);
        }
      };

      // Initial status check
      console.log('w3pk SDK loaded:', window.w3pk);
      window.showResult('w3pk SDK Ready', {
        version: window.w3pk.version,
        isAuthenticated: window.w3pk.isAuthenticated,
        stealthAddresses: !!window.w3pk.stealth,
        zkProofs: !!window.w3pk.zk
      }, 'success');
    </script>
  </body>
</html>
