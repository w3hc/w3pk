# EIP-7951: Account Abstraction via P-256 Passkeys

## Overview

EIP-7951 enables Ethereum accounts to use WebAuthn passkeys (P-256 curve) for signing instead of traditional secp256k1 private keys. This allows for:

- **Native passkey support** - No seed phrases or private key management
- **Hardware-backed security** - Signatures generated in secure enclaves (Secure Enclave, TPM)
- **Account abstraction** - Smart contract wallets that verify WebAuthn signatures on-chain
- **Biometric authentication** - Face ID, Touch ID, Windows Hello, etc.

w3pk implements EIP-7951 PRIMARY mode through the `signMessageWithPasskey()` method and supporting utilities.

## How w3pk Implements EIP-7951

### Architecture

```
┌──────────────────────────────────────────────────────────────┐
│                         User Action                          │
│              w3pk.signMessageWithPasskey(msg)                │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│                     1. Hash Message                          │
│              messageHash = SHA-256(message)                  │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│                 2. Request WebAuthn Signature                │
│         navigator.credentials.get({ challenge: hash })       │
│              User approves with biometric/PIN                │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│              3. WebAuthn Constructs Signed Data              │
│   signedData = authenticatorData || SHA-256(clientDataJSON)  │
│        actualHash = SHA-256(signedData)  [what was signed]   │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│                4. Extract Signature Components               │
│         DER-encoded signature → { r, s } (extractRS)         │
│              Apply low-s normalization (P-256)               │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│              5. Derive Address from P-256 Public Key         │
│     address = keccak256(uncompressed_pubkey)[last 20 bytes]  │
└────────────────────────────┬─────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────┐
│                    Return Signature Result                   │
│    { signature: {r, s}, messageHash, signedHash, address,   │
│                    publicKey: {qx, qy} }                     │
└──────────────────────────────────────────────────────────────┘
```

### Key Components

#### 1. Message Signing with Passkeys

The `signMessageWithPasskey()` method signs messages using WebAuthn P-256:

```typescript
const result = await w3pk.signMessageWithPasskey("Hello World")

// Result contains:
// - signature: { r, s }          - P-256 signature components
// - messageHash                   - Original message hash
// - signedHash                    - WebAuthn signed hash
// - address                       - PRIMARY mode address
// - publicKey: { qx, qy }        - P-256 public key coordinates
```

**Important Differences from secp256k1:**

| Aspect | secp256k1 (Standard) | P-256 (EIP-7951) |
|--------|---------------------|------------------|
| Curve | secp256k1 | P-256 (NIST) |
| Private Key Source | BIP39 mnemonic | WebAuthn credential |
| Signature Format | 65 bytes (r,s,v) | DER-encoded → (r,s) |
| Hash Signed | message hash | authenticatorData ‖ clientDataHash |
| Address Derivation | keccak256(secp256k1 pubkey) | keccak256(P-256 pubkey) |

#### 2. P-256 Address Derivation (EIP-7951)

w3pk derives Ethereum addresses from P-256 public keys using the `deriveAddressFromP256PublicKey()` function:

```typescript
// Internal implementation
export async function deriveAddressFromP256PublicKey(
  publicKeySpki: string  // base64url-encoded SPKI format
): Promise<string> {
  // 1. Import P-256 public key
  const publicKey = await crypto.subtle.importKey(
    "spki",
    base64UrlToArrayBuffer(publicKeySpki),
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["verify"]
  )

  // 2. Export as JWK to get x and y coordinates
  const jwk = await crypto.subtle.exportKey("jwk", publicKey)

  // 3. Create uncompressed public key (64 bytes: x || y)
  const uncompressedKey = new Uint8Array(64)
  uncompressedKey.set(base64UrlToArrayBuffer(jwk.x), 0)   // 32 bytes
  uncompressedKey.set(base64UrlToArrayBuffer(jwk.y), 32)  // 32 bytes

  // 4. Hash with keccak256
  const hash = keccak256(uncompressedKey)

  // 5. Take last 20 bytes as address
  return '0x' + hash.slice(-40)
}
```

This follows the same pattern as secp256k1 address derivation but uses P-256 public key coordinates.

#### 3. DER Signature Parsing with Low-s Normalization

WebAuthn returns signatures in DER format. The `extractRS()` utility extracts r and s components and applies low-s normalization:

```typescript
export function extractRS(derSignature: Uint8Array): { r: string; s: string } {
  // Parse DER format:
  // 0x30 [total-length] 0x02 [r-length] [r-bytes] 0x02 [s-length] [s-bytes]

  // Extract r and s, handling padding
  // Pad to 32 bytes each

  // Apply low-s normalization for P-256
  const n = BigInt('0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551')
  let sBigInt = // ... parse s

  if (sBigInt > n / 2n) {
    sBigInt = n - sBigInt  // Normalize to low-s
  }

  return {
    r: '0x' + rHex,
    s: '0x' + sBigInt.toString(16).padStart(64, '0')
  }
}
```

**Why Low-s Normalization?**

Ethereum requires low-s values to prevent signature malleability. For P-256, we use the curve order:
```
n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551
```

If `s > n/2`, we compute `s' = n - s` to ensure the signature is in canonical form.

#### 4. WebAuthn Signature Construction

WebAuthn doesn't sign the message directly. It constructs a composite hash:

```
1. authenticatorData = device + flags + counter (37+ bytes)
2. clientDataJSON = { type, challenge, origin, ... }
3. clientDataHash = SHA-256(clientDataJSON)
4. signedData = authenticatorData || clientDataHash
5. actualHash = SHA-256(signedData)  ← This is what P-256 signs
```

The `signMessageWithPasskey()` method reconstructs this hash for transparency:

```typescript
// What WebAuthn signed
const authenticatorData = new Uint8Array(response.authenticatorData)
const clientDataHash = await crypto.subtle.digest('SHA-256', response.clientDataJSON)

const signedData = new Uint8Array(authenticatorData.length + clientDataHash.byteLength)
signedData.set(authenticatorData, 0)
signedData.set(new Uint8Array(clientDataHash), authenticatorData.length)

const actualHash = await crypto.subtle.digest('SHA-256', signedData)
```

This `actualHash` is included in the result as `signedHash` for verification purposes.

## Smart Contract Integration

To verify w3pk EIP-7951 signatures on-chain, your smart contract needs to:

### 1. Accept Signature Components

```solidity
struct PasskeySignature {
    bytes32 r;           // Signature r component
    bytes32 s;           // Signature s component
    bytes32 qx;          // Public key x-coordinate
    bytes32 qy;          // Public key y-coordinate
    bytes32 messageHash; // Original message hash
}
```

### 2. Verify P-256 Signature

Use a P-256 verification precompile or library:

```solidity
// Using RIP-7212 P-256 precompile (address 0x100)
function verifyPasskeySignature(
    PasskeySignature memory sig
) public view returns (bool) {
    // Reconstruct signed hash (simplified - actual WebAuthn is more complex)
    bytes32 signedHash = keccak256(abi.encodePacked(
        authenticatorData,
        keccak256(clientDataJSON)
    ));

    // Verify P-256 signature
    (bool success, bytes memory result) = address(0x100).staticcall(
        abi.encodePacked(signedHash, sig.r, sig.s, sig.qx, sig.qy)
    );

    require(success && result.length == 32 && uint256(bytes32(result)) == 1, "Invalid signature");

    return true;
}
```

### 3. Derive and Verify Address

```solidity
function deriveP256Address(bytes32 qx, bytes32 qy) public pure returns (address) {
    // Create uncompressed public key (64 bytes)
    bytes memory pubKey = abi.encodePacked(qx, qy);

    // Hash with keccak256
    bytes32 hash = keccak256(pubKey);

    // Take last 20 bytes as address
    return address(uint160(uint256(hash)));
}

function verifyMessageSigner(
    string memory message,
    PasskeySignature memory sig
) public view returns (bool) {
    // Verify signature
    require(verifyPasskeySignature(sig), "Invalid signature");

    // Derive address from public key
    address signer = deriveP256Address(sig.qx, sig.qy);

    // Verify against expected signer
    return signer == expectedSigner;
}
```

## Complete Example

### Frontend (w3pk)

```typescript
import { createWeb3Passkey } from 'w3pk'

const w3pk = createWeb3Passkey()

// Register user
await w3pk.register({ username: 'alice' })

// Get PRIMARY address (derived from P-256 public key)
const primaryAddress = await w3pk.getAddress('PRIMARY')
console.log('PRIMARY address:', primaryAddress)

// Sign message with passkey
const result = await w3pk.signMessageWithPasskey("Transfer 1 ETH to Bob")

// Verify the address matches
console.log('Signer address:', result.address)
console.assert(result.address === primaryAddress, 'Address should match')

// Send to smart contract
await accountContract.executeWithPasskey({
  message: "Transfer 1 ETH to Bob",
  r: result.signature.r,
  s: result.signature.s,
  qx: result.publicKey.qx,
  qy: result.publicKey.qy
})
```

### Smart Contract (Solidity)

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.20;

contract PasskeyAccount {
    bytes32 public publicKeyX;  // qx
    bytes32 public publicKeyY;  // qy

    constructor(bytes32 qx, bytes32 qy) {
        publicKeyX = qx;
        publicKeyY = qy;
    }

    function executeWithPasskey(
        string memory message,
        bytes32 r,
        bytes32 s,
        bytes32 qx,
        bytes32 qy
    ) public {
        // Verify public key matches
        require(qx == publicKeyX && qy == publicKeyY, "Wrong public key");

        // Verify signature (using P-256 precompile)
        require(verifyP256Signature(message, r, s, qx, qy), "Invalid signature");

        // Execute action
        // ... your logic here
    }

    function verifyP256Signature(
        string memory message,
        bytes32 r,
        bytes32 s,
        bytes32 qx,
        bytes32 qy
    ) internal view returns (bool) {
        // Hash message
        bytes32 messageHash = sha256(abi.encodePacked(message));

        // Call P-256 precompile (RIP-7212)
        (bool success, bytes memory result) = address(0x100).staticcall(
            abi.encodePacked(messageHash, r, s, qx, qy)
        );

        return success && result.length == 32 && uint256(bytes32(result)) == 1;
    }
}
```

## Exported Utilities

w3pk exports several utilities for working with EIP-7951:

### Base64 Encoding

```typescript
import {
  base64UrlToArrayBuffer,
  arrayBufferToBase64Url,
  base64UrlDecode
} from 'w3pk'

// Decode WebAuthn credential ID
const credentialId = base64UrlToArrayBuffer(user.credentialId)

// Encode public key
const publicKeyBase64 = arrayBufferToBase64Url(publicKeyBuffer)
```

### Signature Parsing

```typescript
import { extractRS } from 'w3pk'

// Extract r,s from WebAuthn DER signature
const assertion = await navigator.credentials.get({ publicKey: options })
const derSignature = new Uint8Array(assertion.response.signature)
const { r, s } = extractRS(derSignature)

console.log('r:', r)  // 0x1234...
console.log('s:', s)  // 0x5678... (low-s normalized)
```

### Address Derivation

```typescript
import { deriveAddressFromP256PublicKey } from 'w3pk'

// Low-level: Derive Ethereum address from P-256 public key
const address = await deriveAddressFromP256PublicKey(publicKeySpki)
console.log('PRIMARY address:', address)

// High-level: Get PRIMARY address directly from Web3Passkey instance
const w3pk = createWeb3Passkey()
await w3pk.login()

const primaryAddr = await w3pk.getAddress('PRIMARY')
console.log('PRIMARY address:', primaryAddr)
```

### Get Address Without Private Key Exposure

The `getAddress()` method provides a lightweight way to retrieve addresses for any security mode:

```typescript
// Get default STANDARD + MAIN address
const mainAddr = await w3pk.getAddress()

// Get PRIMARY address (P-256 from passkey)
const primaryAddr = await w3pk.getAddress('PRIMARY')

// Get addresses for different tags
const gamingAddr = await w3pk.getAddress('YOLO', 'GAMING')
const tradingAddr = await w3pk.getAddress('STANDARD', 'TRADING')

// Display all addresses in UI
const addresses = {
  primary: await w3pk.getAddress('PRIMARY'),
  standard: await w3pk.getAddress('STANDARD'),
  strict: await w3pk.getAddress('STRICT'),
  yolo: await w3pk.getAddress('YOLO')
}

console.log('Available addresses:', addresses)
```

**Benefits:**
- Never exposes private keys (even in YOLO mode)
- Lightweight - just returns the address string
- Perfect for UI display and verification
- Supports all security modes including PRIMARY
```

## Security Considerations

### 1. Signature Malleability

w3pk automatically applies low-s normalization using the P-256 curve order to prevent signature malleability:

```typescript
const n = BigInt('0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551')

if (s > n / 2n) {
  s = n - s  // Normalize to low-s
}
```

### 2. Origin Binding

WebAuthn signatures are bound to the origin (RP ID). The signature includes:
- `rpIdHash` - SHA-256 hash of the RP ID (domain)
- Prevents cross-origin signature replay

Smart contracts should verify the origin matches expected values.

### 3. Counter Validation

WebAuthn includes a signature counter that increments with each use. This prevents:
- Credential cloning
- Replay attacks

w3pk tracks and validates signature counters in credential storage.

### 4. Hardware Security

P-256 passkeys are typically stored in:
- iOS/macOS: Secure Enclave
- Android: Titan M / StrongBox
- Windows: TPM 2.0

Private keys never leave the secure hardware.

## Comparison with Standard Mode

| Feature | Standard Mode (secp256k1) | PRIMARY Mode (P-256) |
|---------|-------------------------|---------------------|
| **Method** | `w3pk.signMessage()` | `w3pk.signMessageWithPasskey()` |
| **Curve** | secp256k1 | P-256 (NIST) |
| **Private Key** | BIP39 mnemonic | WebAuthn credential |
| **Hardware** | Software (in memory) | Secure enclave |
| **Seed Phrase** | Yes (12/24 words) | No seed phrase |
| **Address Type** | Standard Ethereum | EIP-7951 P-256 |
| **Smart Contract** | Standard EOA | Account abstraction |
| **Use Case** | Traditional wallets | Passkey-first wallets |

## Browser Support

EIP-7951 (PRIMARY mode) requires WebAuthn Level 2 support:

| Browser | Support | Notes |
|---------|---------|-------|
| Chrome 67+ | ✅ | Full support |
| Firefox 60+ | ✅ | Full support |
| Safari 13+ | ✅ | Full support |
| Edge 18+ | ✅ | Full support |

All modern browsers support P-256 WebAuthn signatures.

## Related Standards

- **EIP-7951**: Account Abstraction via SECP256R1 (P-256)
- **RIP-7212**: P-256 signature verification precompile
- **WebAuthn Level 2**: Web Authentication API
- **FIDO2**: Client to Authenticator Protocol (CTAP2)
- **ERC-4337**: Account Abstraction via Entry Point

## Resources

- [EIP-7951 Specification](https://eips.ethereum.org/EIPS/eip-7951)
- [RIP-7212 Precompile](https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md)
- [WebAuthn Specification](https://www.w3.org/TR/webauthn-2/)
- [P-256 Curve Parameters](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf)
- [w3pk API Reference](./API_REFERENCE.md#signmessagewithpasskey)

## Examples

See working examples in the w3pk repository:
- [Primary Mode Signing](../examples/primary-mode-signing.ts)
- [Smart Contract Integration](../examples/passkey-account-contract.sol)
- [Address Derivation](../examples/p256-address-derivation.ts)
