# EIP-7702 Authorization Signatures with W3PK

This guide explains how to use the `signAuthorization()` method in w3pk to create EIP-7702 authorization signatures for gasless transactions.

## Table of Contents

1. [Overview](#overview)
2. [Basic Usage](#basic-usage)
3. [Derived Addresses](#derived-addresses)
4. [Stealth Addresses (ERC-5564)](#stealth-addresses-erc-5564)
5. [Integration Examples](#integration-examples)
6. [Security Considerations](#security-considerations)

---

## Overview

EIP-7702 allows EOAs (Externally Owned Accounts) to **permanently delegate** code execution to a contract through authorization signatures. This enables:

- **Zero ETH required** - DAO treasury or sponsor pays all gas
- **Gasless transactions** - Users don't need gas tokens
- **One-time authorization** - Sign ONCE, use forever
- **Native protocol support** - Works on 329+ EVM chains
- **Privacy support** - Works with stealth addresses

### How It Works

**One-Time Setup:**
1. User signs an authorization (offline, free)
2. Authorization is included in **first transaction**
3. User's EOA **permanently delegates** to contract code
4. Sponsor pays the gas costs

**All Future Transactions:**
5. User just sends transactions normally (no authorization needed)
6. EOA still has delegated contract code
7. Sponsor continues paying gas costs

**IMPORTANT:** EIP-7702 authorization is **PERSISTENT** - you sign it ONCE and your EOA delegates to the contract code permanently until you explicitly revoke it by signing a new authorization.

---

## Basic Usage

### Default Address (Index 0)

The simplest usage signs with the default address (BIP44 index 0):

```typescript
import { createWeb3Passkey } from "w3pk";

const sdk = createWeb3Passkey();

// Register or login
await sdk.register({ username: "alice" });

// Sign authorization with default address
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111, // Sepolia
  nonce: 0n, // Optional, defaults to 0
});

console.log("Authorization:", {
  chainId: authorization.chainId,
  address: authorization.address, // Your default address
  nonce: authorization.nonce,
  yParity: authorization.yParity,
  r: authorization.r,
  s: authorization.s,
});
```

### Using the Authorization

**First Transaction (Setup):**

Include the authorization in your FIRST transaction to establish permanent delegation:

```typescript
// With viem
import { walletClient, publicClient } from "./config";
import { encodeFunctionData } from "viem";

// First transaction - includes authorization
const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "propose",
    args: [targets, values, calldatas, description],
  }),
  authorizationList: [authorization], // Establishes permanent delegation
});

await publicClient.waitForTransactionReceipt({ hash });
console.log("Transaction successful! User paid 0 ETH. Delegation is now permanent!");
```

**All Subsequent Transactions:**

After the first transaction, NO authorization is needed:

```typescript
// All future transactions - NO authorization needed!
const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1],
  }),
  // No authorizationList - delegation persists!
});

await publicClient.waitForTransactionReceipt({ hash });
console.log("Vote cast! User still paid 0 ETH.");
```

---

## Derived Addresses

To sign from a specific derived address (BIP44 path `m/44'/60'/0'/0/{index}`):

### Step 1: Get the Private Key

```typescript
import { deriveWalletFromMnemonic } from "w3pk";

// Get mnemonic from secure source (session, WebAuthn, etc.)
const mnemonic = await sdk.getMnemonicFromSession();

// Derive wallet at specific index
const { address, privateKey } = deriveWalletFromMnemonic(mnemonic, 5);

console.log("Derived address:", address);
```

### Step 2: Sign Authorization

```typescript
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  privateKey, // Use the derived private key
});

console.log("Signed from:", authorization.address);
// Output: Signed from: 0x... (address from index 5)
```

### Complete Example

```typescript
import { createWeb3Passkey, deriveWalletFromMnemonic } from "w3pk";

const sdk = createWeb3Passkey();
await sdk.register({ username: "alice" });

// Get mnemonic (triggers WebAuthn if session expired)
const mnemonic = await sdk.getMnemonicFromSession();

// Derive multiple addresses
const wallets = Array.from({ length: 10 }, (_, i) =>
  deriveWalletFromMnemonic(mnemonic, i)
);

// Sign from address at index 3
const auth = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  privateKey: wallets[3].privateKey,
});

console.log("Signed from derived address:", auth.address);
```

---

## Stealth Addresses (ERC-5564)

W3PK supports signing EIP-7702 authorizations from stealth addresses using the ERC-5564 standard.

### Step 1: Compute Stealth Private Key

```typescript
import { computeStealthPrivateKey, deriveStealthKeys } from "w3pk";

// Get your stealth keys
const mnemonic = await sdk.getMnemonicFromSession();
const { viewingKey, spendingKey } = deriveStealthKeys(mnemonic);

// Get ephemeral public key from ERC-5564 announcement
const ephemeralPubKey = "0x..."; // From blockchain event

// Compute stealth private key
const stealthPrivateKey = computeStealthPrivateKey(
  viewingKey,
  spendingKey,
  ephemeralPubKey
);
```

### Step 2: Sign Authorization from Stealth Address

```typescript
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  privateKey: stealthPrivateKey, // Use stealth private key
});

console.log("Signed from stealth address:", authorization.address);
```

### Complete Stealth Address Example

```typescript
import {
  createWeb3Passkey,
  deriveStealthKeys,
  computeStealthPrivateKey,
  checkStealthAddress,
} from "w3pk";

const sdk = createWeb3Passkey({
  stealthAddresses: {
    enabled: true,
  },
});

await sdk.register({ username: "bob" });

// Generate stealth keys
const mnemonic = await sdk.getMnemonicFromSession();
const { viewingKey, spendingKey, spendingPublicKey, viewingPublicKey } =
  deriveStealthKeys(mnemonic);

// Publish your meta-address (viewing + spending public keys)
// Store on-chain or in profile

// Later: Scan for stealth addresses
const announcements = await getStealthAnnouncements(); // From contract events

for (const announcement of announcements) {
  const { isForUser, stealthAddress } = checkStealthAddress({
    ephemeralPubKey: announcement.ephemeralPubKey,
    stealthAddress: announcement.stealthAddress,
    viewingKey,
    spendingPublicKey,
  });

  if (isForUser) {
    console.log("Found stealth payment:", stealthAddress);

    // Compute private key to spend from this address
    const stealthPrivKey = computeStealthPrivateKey(
      viewingKey,
      spendingKey,
      announcement.ephemeralPubKey
    );

    // Sign authorization from stealth address
    const auth = await sdk.signAuthorization({
      contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
      chainId: 11155111,
      privateKey: stealthPrivKey,
    });

    // Submit gasless transaction
    await submitTransaction(auth);
  }
}
```

---

## Integration Examples

### Governance DAO (Gasless Voting)

**First-Time User (Setup):**

```typescript
import { createWeb3Passkey } from "w3pk";
import { encodeFunctionData } from "viem";

const sdk = createWeb3Passkey();
await sdk.login("alice");

// Sign authorization for voting (ONCE)
const authorization = await sdk.signAuthorization({
  contractAddress: govContractAddress,
  chainId: 11155111,
  nonce: 0n,
});

// Cast FIRST vote (establishes delegation permanently)
const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1], // Vote FOR
  }),
  authorizationList: [authorization], // Only needed first time
});

console.log("Voted! User paid 0 ETH. Setup complete!");
```

**Returning User (Already Authorized):**

```typescript
// No authorization needed - just vote!
const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1],
  }),
  // No authorizationList - delegation persists from first transaction
});

console.log("Voted! User paid 0 ETH.");
```

### Private Voting with Stealth Address

```typescript
// Receive voting rights to stealth address
const stealthAddr = "0x..."; // From ERC-5564 announcement

// Compute stealth private key
const stealthPrivKey = computeStealthPrivateKey(
  viewingKey,
  spendingKey,
  ephemeralPubKey
);

// Vote anonymously from stealth address
const authorization = await sdk.signAuthorization({
  contractAddress: govContractAddress,
  chainId: 11155111,
  privateKey: stealthPrivKey,
});

// Submit vote (anonymous + gasless)
await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1],
  }),
  authorizationList: [authorization],
});
```

### Multi-Signature from Derived Addresses

```typescript
// Sign from multiple derived addresses
const mnemonic = await sdk.getMnemonicFromSession();
const signers = [0, 1, 2].map(i => deriveWalletFromMnemonic(mnemonic, i));

const authorizations = await Promise.all(
  signers.map(({ privateKey }) =>
    sdk.signAuthorization({
      contractAddress: multiSigContractAddress,
      chainId: 1,
      privateKey,
    })
  )
);

// Submit multi-sig transaction
await walletClient.sendTransaction({
  to: multiSigContractAddress,
  data: executeData,
  authorizationList: authorizations,
});
```

---

## Security Considerations

### Private Key Handling

**DO:**
- ✅ Derive private keys only when needed
- ✅ Clear private keys from memory immediately after use
- ✅ Use WebAuthn-gated session management
- ✅ Validate contract addresses before signing

**DON'T:**
- ❌ Store private keys in localStorage or sessionStorage
- ❌ Log private keys to console
- ❌ Share private keys across insecure channels
- ❌ Reuse private keys across different operations

### Authorization Signatures

**CRITICAL:** EIP-7702 authorizations are **PERMANENT** until explicitly revoked!

**DO:**
- ✅ Verify contract address before signing (delegation is permanent!)
- ✅ Understand that your EOA will delegate to this contract indefinitely
- ✅ Only authorize audited, verified, trusted contracts
- ✅ Know how to revoke authorization (sign new authorization to 0x0 or different contract)
- ✅ Use appropriate nonce values
- ✅ Monitor authorization usage on-chain

**DON'T:**
- ❌ Think of authorization as "temporary" or "session-based" - it persists!
- ❌ Sign authorizations for unknown contracts
- ❌ Authorize contracts you don't fully trust
- ❌ Reuse authorizations across different chains
- ❌ Share authorization signatures publicly

### Stealth Addresses

**DO:**
- ✅ Keep viewing and spending keys separate
- ✅ Validate ephemeral public keys before computing stealth keys
- ✅ Verify stealth addresses match announcements
- ✅ Use fresh ephemeral keys for each stealth address

**DON'T:**
- ❌ Expose viewing keys (breaks privacy)
- ❌ Reuse ephemeral keys
- ❌ Derive stealth keys from untrusted announcements

### Best Practices

1. **Session Management**
   ```typescript
   // Good: Use session with timeout
   const sdk = createWeb3Passkey({
     sessionDuration: 15, // 15 minutes
   });

   // Authorization triggers WebAuthn if session expired
   const auth = await sdk.signAuthorization({
     contractAddress: "0x...",
     requireAuth: true, // Force fresh authentication
   });
   ```

2. **Error Handling**
   ```typescript
   try {
     const auth = await sdk.signAuthorization({
       contractAddress: govContractAddress,
       chainId: 11155111,
       privateKey: stealthPrivKey,
     });
   } catch (error) {
     if (error.message.includes("Must be authenticated")) {
       // Session expired, user needs to login
       await sdk.login(username);
     } else if (error.message.includes("Invalid private key")) {
       // Private key format issue
       console.error("Check private key format");
     } else {
       throw error;
     }
   }
   ```

3. **Gas Estimation**
   ```typescript
   // Estimate gas before submitting
   const gasEstimate = await publicClient.estimateGas({
     to: govContractAddress,
     data: proposalData,
     authorizationList: [authorization],
   });

   console.log("Estimated gas:", gasEstimate);
   ```

4. **Check if Already Authorized**
   ```typescript
   // Check if user's EOA already has delegated code
   const code = await publicClient.getCode({ address: userAddress });
   const isAuthorized = code && code.length > 2;

   if (isAuthorized) {
     console.log("User already authorized - no need to include authorizationList");
     // Just send transaction normally
   } else {
     console.log("First time - need to include authorizationList");
     // Include authorization in first transaction
   }
   ```

5. **Revoking Authorization**
   ```typescript
   // To revoke delegation, sign new authorization to zero address
   const revocation = await sdk.signAuthorization({
     contractAddress: "0x0000000000000000000000000000000000000000",
     chainId: 11155111,
     nonce: currentNonce + 1n,
   });

   // Send transaction with revocation
   await walletClient.sendTransaction({
     to: userAddress, // Send to self
     value: 0n,
     authorizationList: [revocation],
   });

   console.log("Delegation revoked!");
   ```

---

## API Reference

### `signAuthorization(params, options?)`

Signs an EIP-7702 authorization for gasless transactions.

**Parameters:**

```typescript
params: {
  contractAddress: string;  // Contract to authorize
  chainId?: number;         // Chain ID (default: 1)
  nonce?: bigint;           // Nonce (default: 0n)
  privateKey?: string;      // Optional private key (default: account 0)
}

options?: {
  requireAuth?: boolean;    // Force fresh authentication
}
```

**Returns:**

```typescript
Promise<{
  chainId: bigint;
  address: string;
  nonce: bigint;
  yParity: number;
  r: string;
  s: string;
}>
```

**Example:**

```typescript
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  nonce: 0n,
  privateKey: "0x...", // Optional
}, {
  requireAuth: true, // Optional
});
```

---

## Related Documentation

- [EIP-7702 Specification](https://eips.ethereum.org/EIPS/eip-7702)
- [ERC-5564 Stealth Addresses](../misc/ERC5564_STEALTH_ADDRESSES.md)
- [W3PK API Reference](./API_REFERENCE.md)
- [Stealth Address Integration](./ZK.md)
- [Gov Integration Guide](/Users/ju/gov-crosschain/docs/INTEGRATION_GUIDE.md)

---

## Support

For issues or questions:
- GitHub: [w3pk/issues](https://github.com/your-repo/w3pk/issues)
- Documentation: [docs/](../docs/)
- Examples: [examples/](../examples/)
