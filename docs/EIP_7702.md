# EIP-7702 Authorization Signatures with W3PK

This guide explains how to use EIP-7702 in W3PK to enable gasless transactions through authorization signatures.

## Table of Contents

1. [Overview](#overview)
2. [EIP-7702 Supported Chain IDs](#eip-7702-supported-chain-ids)
3. [signAuthorization Method](#signauthorization-method)
4. [External Wallets](#external-wallets)
5. [Integration Examples](#integration-examples)
6. [Security Considerations](#security-considerations)

---

## Overview

EIP-7702 allows EOAs (Externally Owned Accounts) to **permanently delegate** code execution to a contract through authorization signatures. This enables:

- **Zero ETH required** - DAO treasury or sponsor pays all gas
- **Gasless transactions** - Users don't need gas tokens
- **One-time authorization** - Sign ONCE, use forever
- **Native protocol support** - Works across supported EVM chains
- **Privacy support** - Works with stealth addresses

### How It Works

**One-Time Setup:**
1. User signs an authorization (offline, free)
2. Authorization is included in **first transaction**
3. User's EOA **permanently delegates** to contract code
4. Sponsor pays the gas costs

**All Future Transactions:**
5. User just sends transactions normally (no authorization needed)
6. EOA still has delegated contract code
7. Sponsor continues paying gas costs

**IMPORTANT:** EIP-7702 authorization is **PERSISTENT** - you sign it ONCE and your EOA delegates to the contract code permanently until you explicitly revoke it by signing a new authorization.

---

## EIP-7702 Supported Chain IDs

W3PK supports EIP-7702 authorizations on the following chains:

### Mainnet Chains

| Chain Name | Chain ID | Status |
|------------|----------|--------|
| Ethereum Mainnet | 1 | ✅ Supported |
| Odyssey Mainnet | 911867 | ✅ Supported |

### Testnet Chains

| Chain Name | Chain ID | Status |
|------------|----------|--------|
| Sepolia | 11155111 | ✅ Supported |
| Odyssey Testnet | 97430 | ✅ Supported |

### Using Custom Chain IDs

You can specify any chain ID when creating an authorization. The `signAuthorization` method accepts any valid chain ID:

```typescript
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1, // Or any supported chain ID
});
```

**Note:** While W3PK can sign authorizations for any chain ID, the actual EIP-7702 support depends on whether the target chain has implemented the EIP-7702 specification. Always verify that your target chain supports EIP-7702 before using this feature.

---

## signAuthorization Method

The `signAuthorization()` method is the core API for creating EIP-7702 authorization signatures. It supports multiple signing modes to accommodate different use cases.

### Method Signature

```typescript
async signAuthorization(
  params: {
    contractAddress: string;  // Contract to delegate to
    chainId?: number;         // Chain ID (default: 1)
    nonce?: bigint;          // Nonce (default: 0n)
    privateKey?: string;     // Optional: For derived/stealth addresses
  },
  options?: {
    requireAuth?: boolean;   // Force fresh WebAuthn authentication
  }
): Promise<{
  chainId: bigint;
  address: string;           // Address that signed the authorization
  nonce: bigint;
  yParity: number;
  r: string;
  s: string;
}>
```

### Basic Usage (Default Address)

Sign with the W3PK default address (BIP44 index 0):

```typescript
import { createWeb3Passkey } from "w3pk";

const sdk = createWeb3Passkey();
await sdk.register({ username: "alice" });

// Sign authorization with default address
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111, // Sepolia
  nonce: 0n,
});

console.log("Signed from:", authorization.address);
```

### Using Custom Private Keys

Sign from derived addresses or stealth addresses by providing a private key:

```typescript
import { deriveWalletFromMnemonic } from "w3pk";

// Get mnemonic from session
const mnemonic = await sdk.getMnemonicFromSession();

// Derive wallet at index 5
const { address, privateKey } = deriveWalletFromMnemonic(mnemonic, 5);

// Sign authorization from derived address
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  privateKey, // Sign from derived address
});

console.log("Signed from:", authorization.address); // Address at index 5
```

### Using the Authorization

**First Transaction (Setup):**

Include the authorization in your FIRST transaction to establish permanent delegation:

```typescript
import { walletClient, publicClient } from "./config";
import { encodeFunctionData } from "viem";

const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "propose",
    args: [targets, values, calldatas, description],
  }),
  authorizationList: [authorization], // Establishes permanent delegation
});

await publicClient.waitForTransactionReceipt({ hash });
console.log("Delegation is now permanent!");
```

**All Subsequent Transactions:**

After the first transaction, NO authorization is needed:

```typescript
const hash = await walletClient.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1],
  }),
  // No authorizationList - delegation persists!
});
```

### Advanced Options

**Force Fresh Authentication:**

```typescript
const authorization = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1,
}, {
  requireAuth: true, // Always trigger WebAuthn prompt
});
```

**Check Authorization Status:**

```typescript
// Check if address already has delegated code
const code = await publicClient.getCode({ address: userAddress });
const isAuthorized = code && code.length > 2;

if (!isAuthorized) {
  // Need to include authorization in next transaction
}
```

**Revoke Authorization:**

```typescript
// Sign authorization to zero address to revoke delegation
const revocation = await sdk.signAuthorization({
  contractAddress: "0x0000000000000000000000000000000000000000",
  chainId: 11155111,
  nonce: currentNonce + 1n,
});

await walletClient.sendTransaction({
  to: userAddress,
  value: 0n,
  authorizationList: [revocation],
});
```

---

## External Wallets

W3PK supports integrating external wallets for EIP-7702 authorizations. This allows users to sign authorizations using wallets outside the W3PK ecosystem (e.g., MetaMask, WalletConnect, hardware wallets).

### What are External Wallets?

External wallets are Ethereum wallets that exist outside of W3PK's passkey-based system. They include:

- Browser extension wallets (MetaMask, Rainbow, etc.)
- Hardware wallets (Ledger, Trezor)
- Mobile wallets (Rainbow, Trust Wallet)
- WalletConnect-compatible wallets

### Use Cases

1. **Hybrid Authorization** - Combine W3PK passkey accounts with external wallet accounts
2. **Multi-Signature** - Require authorizations from both W3PK and external wallets
3. **Migration** - Transition existing wallet users to W3PK while maintaining their addresses
4. **Enterprise** - Use hardware wallets for high-value authorizations

### Using viem with External Wallets

W3PK provides utilities to work with external wallets through viem:

```typescript
import { createExternalWalletClient, signAuthorizationWithExternalWallet } from "w3pk";
import { createWalletClient, custom } from "viem";
import { sepolia } from "viem/chains";

// Connect to MetaMask
const walletClient = createWalletClient({
  chain: sepolia,
  transport: custom(window.ethereum),
});

// Get external wallet address
const [externalAddress] = await walletClient.getAddresses();

// Sign authorization with external wallet
const authorization = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
  nonce: 0n,
});

console.log("External wallet signed:", authorization.address);
```

### Combining W3PK and External Wallets

Create multi-signature authorizations combining W3PK passkeys and external wallets:

```typescript
import { createWeb3Passkey, signAuthorizationWithExternalWallet } from "w3pk";
import { createWalletClient, custom } from "viem";
import { sepolia } from "viem/chains";

const sdk = createWeb3Passkey();
await sdk.login("alice");

// W3PK authorization
const w3pkAuth = await sdk.signAuthorization({
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
});

// External wallet authorization
const walletClient = createWalletClient({
  chain: sepolia,
  transport: custom(window.ethereum),
});

const externalAuth = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 11155111,
});

// Submit transaction with both authorizations
await sponsorWallet.sendTransaction({
  to: multiSigContract,
  data: executeData,
  authorizationList: [w3pkAuth, externalAuth],
});
```

### ENS Delegation to W3PK

Delegate ENS-resolved addresses to W3PK contracts for gasless operations:

```typescript
import { normalize } from "viem/ens";
import { createPublicClient, http } from "viem";
import { mainnet } from "viem/chains";

// Resolve ENS name to address
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
});

const ensAddress = await publicClient.getEnsAddress({
  name: normalize("alice.eth"),
});

// User signs with their ENS-linked wallet
const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum),
});

const authorization = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1,
});

console.log("ENS address authorized:", authorization.address);
// Now alice.eth can use gasless transactions!
```

### Hardware Wallet Integration

Use hardware wallets for secure, high-value authorizations:

```typescript
import { createWalletClient, custom } from "viem";
import { mainnet } from "viem/chains";
import LedgerConnector from "@ledgerhq/wallet-api-client";

// Connect to Ledger
const ledger = new LedgerConnector();
await ledger.connect();

const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(ledger.provider),
});

// Sign with hardware wallet
const authorization = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1,
});

console.log("Hardware wallet signed:", authorization.address);
```

### WalletConnect Integration

Support mobile wallets via WalletConnect:

```typescript
import { createWalletClient, custom } from "viem";
import { mainnet } from "viem/chains";
import { EthereumProvider } from "@walletconnect/ethereum-provider";

// Initialize WalletConnect
const provider = await EthereumProvider.init({
  projectId: "YOUR_PROJECT_ID",
  chains: [1],
  showQrModal: true,
});

await provider.connect();

const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(provider),
});

const authorization = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1,
});
```

### Security Considerations for External Wallets

**DO:**
- ✅ Verify the external wallet is connected to the correct chain
- ✅ Validate the wallet address before signing
- ✅ Use hardware wallets for high-value authorizations
- ✅ Implement proper wallet connection state management

**DON'T:**
- ❌ Trust external wallet connections without verification
- ❌ Assume external wallets support all EIP-7702 features
- ❌ Skip user confirmation dialogs for authorizations
- ❌ Store external wallet private keys (they're managed by the wallet)

---

## Integration Examples

### Example 1: Gasless Governance Voting

Enable DAO members to vote without gas costs using their W3PK passkey:

```typescript
import { createWeb3Passkey } from "w3pk";
import { encodeFunctionData } from "viem";

const sdk = createWeb3Passkey();
await sdk.login("alice");

// Sign authorization once
const authorization = await sdk.signAuthorization({
  contractAddress: govContractAddress,
  chainId: 11155111,
});

// First vote - includes authorization
const hash = await sponsorWallet.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [proposalId, 1],
  }),
  authorizationList: [authorization],
});

// All future votes - no authorization needed
const nextVote = await sponsorWallet.sendTransaction({
  to: govContractAddress,
  data: encodeFunctionData({
    abi: govAbi,
    functionName: "castVote",
    args: [nextProposalId, 1],
  }),
});
```

### Example 2: External Wallet + W3PK Multi-Sig

Combine external wallet and W3PK authorizations for enhanced security:

```typescript
import { createWeb3Passkey, signAuthorizationWithExternalWallet } from "w3pk";
import { createWalletClient, custom } from "viem";

const sdk = createWeb3Passkey();
await sdk.login("alice");

// W3PK passkey authorization
const passkeyAuth = await sdk.signAuthorization({
  contractAddress: multiSigContract,
  chainId: 1,
});

// MetaMask authorization
const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum),
});

const externalAuth = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: multiSigContract,
  chainId: 1,
});

// Submit with both authorizations
await sponsorWallet.sendTransaction({
  to: multiSigContract,
  data: executeData,
  authorizationList: [passkeyAuth, externalAuth],
});
```

### Example 3: ENS to W3PK Delegation

Allow ENS users to delegate their ENS-linked addresses to W3PK for gasless transactions:

```typescript
import { normalize } from "viem/ens";
import { createPublicClient, createWalletClient, custom, http } from "viem";
import { mainnet } from "viem/chains";
import { signAuthorizationWithExternalWallet } from "w3pk";

// Resolve ENS name
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
});

const ensAddress = await publicClient.getEnsAddress({
  name: normalize("alice.eth"),
});

// User connects wallet
const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum),
});

// Sign authorization with ENS-linked wallet
const authorization = await signAuthorizationWithExternalWallet(walletClient, {
  contractAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
  chainId: 1,
});

// Now alice.eth can use gasless transactions
console.log("ENS address authorized:", authorization.address);
```

### Example 4: Derived Address Multi-Signature

Use multiple derived addresses from a single W3PK mnemonic:

```typescript
import { createWeb3Passkey, deriveWalletFromMnemonic } from "w3pk";

const sdk = createWeb3Passkey();
await sdk.login("alice");

const mnemonic = await sdk.getMnemonicFromSession();

// Derive 3 addresses and sign from each
const authorizations = await Promise.all(
  [0, 1, 2].map(async (index) => {
    const { privateKey } = deriveWalletFromMnemonic(mnemonic, index);
    return sdk.signAuthorization({
      contractAddress: multiSigContract,
      chainId: 1,
      privateKey,
    });
  })
);

// Submit with all authorizations
await sponsorWallet.sendTransaction({
  to: multiSigContract,
  data: executeData,
  authorizationList: authorizations,
});
```

### Example 5: Stealth Address Authorization

Sign authorizations from ERC-5564 stealth addresses for private transactions:

```typescript
import {
  createWeb3Passkey,
  deriveStealthKeys,
  computeStealthPrivateKey
} from "w3pk";

const sdk = createWeb3Passkey({
  stealthAddresses: { enabled: true },
});

await sdk.login("bob");

// Generate stealth keys
const mnemonic = await sdk.getMnemonicFromSession();
const { viewingKey, spendingKey } = deriveStealthKeys(mnemonic);

// Get ephemeral key from ERC-5564 announcement
const announcement = await getAnnouncementFromChain();

// Compute stealth private key
const stealthPrivKey = computeStealthPrivateKey(
  viewingKey,
  spendingKey,
  announcement.ephemeralPubKey
);

// Sign authorization from stealth address
const authorization = await sdk.signAuthorization({
  contractAddress: govContract,
  chainId: 11155111,
  privateKey: stealthPrivKey,
});

// Vote anonymously and gaslessly
await sponsorWallet.sendTransaction({
  to: govContract,
  data: voteData,
  authorizationList: [authorization],
});
```

---

## Security Considerations

### Critical: Authorization Persistence

**IMPORTANT:** EIP-7702 authorizations are **PERMANENT** until explicitly revoked!

Your EOA will delegate to the contract code indefinitely. Only authorize audited, verified, and fully trusted contracts.

### Private Key Security

**DO:**
- ✅ Derive private keys only when needed
- ✅ Clear private keys from memory immediately after use
- ✅ Use WebAuthn-gated session management
- ✅ Validate contract addresses before signing

**DON'T:**
- ❌ Store private keys in localStorage or sessionStorage
- ❌ Log private keys to console
- ❌ Share private keys across insecure channels
- ❌ Reuse private keys for different operations

### Authorization Best Practices

**DO:**
- ✅ Verify contract address before signing (delegation is permanent!)
- ✅ Only authorize audited, verified, trusted contracts
- ✅ Use appropriate nonce values (increment for revocations)
- ✅ Monitor authorization usage on-chain
- ✅ Check if already authorized before including authorizationList

**DON'T:**
- ❌ Think of authorization as "temporary" or "session-based"
- ❌ Sign authorizations for unknown or unaudited contracts
- ❌ Reuse authorization signatures across different chains
- ❌ Share authorization signatures publicly

### External Wallet Security

**DO:**
- ✅ Verify external wallet is connected to correct chain
- ✅ Validate wallet address before signing
- ✅ Use hardware wallets for high-value authorizations
- ✅ Implement proper wallet connection state management

**DON'T:**
- ❌ Trust external wallet connections without verification
- ❌ Skip user confirmation dialogs
- ❌ Attempt to access or store external wallet private keys

### Stealth Address Privacy

**DO:**
- ✅ Keep viewing and spending keys separate
- ✅ Validate ephemeral public keys before computing stealth keys
- ✅ Verify stealth addresses match ERC-5564 announcements
- ✅ Use fresh ephemeral keys for each stealth address

**DON'T:**
- ❌ Expose viewing keys (breaks privacy for all stealth addresses)
- ❌ Reuse ephemeral keys
- ❌ Derive stealth keys from untrusted announcements

### Implementation Examples

**Check Authorization Status:**

```typescript
// Verify if EOA already has delegated code
const code = await publicClient.getCode({ address: userAddress });
const isAuthorized = code && code.length > 2;

if (!isAuthorized) {
  // Include authorization in next transaction
}
```

**Session Management:**

```typescript
const sdk = createWeb3Passkey({
  sessionDuration: 15, // 15 minutes
});

// Force fresh authentication for sensitive operations
const auth = await sdk.signAuthorization({
  contractAddress: "0x...",
}, {
  requireAuth: true,
});
```

**Error Handling:**

```typescript
try {
  const auth = await sdk.signAuthorization({
    contractAddress: govContract,
    chainId: 11155111,
  });
} catch (error) {
  if (error.message.includes("Must be authenticated")) {
    await sdk.login(username);
  } else {
    console.error("Authorization failed:", error);
  }
}
```

---

## Related Documentation

- [EIP-7702 Specification](https://eips.ethereum.org/EIPS/eip-7702)
- [ENS to W3PK Delegation Guide](./ENS_TO_W3PK_DELEGATION.md)
- [ERC-5564 Stealth Addresses](../misc/ERC5564_STEALTH_ADDRESSES.md)
- [W3PK API Reference](./API_REFERENCE.md)
- [External Wallet Integration](../src/eip7702/external-wallet.ts)

---

## Support

For issues or questions:
- GitHub: [w3pk/issues](https://github.com/your-repo/w3pk/issues)
- Documentation: [docs/](../docs/)
- Examples: [examples/](../examples/)
